<style>body {margin: 0;} canvas {
  image-rendering: optimizeSpeed;             /* Older versions of FF          */
  image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
  image-rendering: -webkit-optimize-contrast; /* Safari                        */
  image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
  image-rendering: pixelated;                 /* Awesome future-browsers       */
  -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
}</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.11.2/lodash.min.js"></script>

<script>
  const GRID_SIZE = { w: 32, h: 32 };

  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  const mouse = { x: window.innerWidth / 2, y: window.innerWidth / 2 };

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const wallTiles = loadTerrainTiles('tiles/ground-bitmask-tiles-reordered.png', () => {
    canvas.style.backgroundImage = `url(${wallTiles[15].toDataURL()})`;
  });

  const map = {
    walls: []
  };

  function pxToGrid(x, y) {
    return {
      col: Math.floor(x / GRID_SIZE.w),
      row: Math.floor(y / GRID_SIZE.h)
    }
  }

  function mouseToGrid(e) {
    return pxToGrid(e.clientX, e.clientY);
  }

  function loadTerrainTiles(src, callback) {
    const tiles = _.times(16, i => document.createElement('canvas'));
    const texture = new Image();

    texture.src = src;

    texture.addEventListener('load', () => {
      tiles.forEach((tileCanvas, i) => {
        const tileContext = tileCanvas.getContext('2d');
        const col = i % 4;
        const row = Math.floor(i / 4);

        tileCanvas.width = GRID_SIZE.w;
        tileCanvas.height = GRID_SIZE.h;

        const src = {
          x: col * texture.width / 4,
          y: row * texture.height / 4,
          w: texture.width / 4,
          h: texture.height / 4
        };

        tileContext.drawImage(texture, src.x, src.y, src.w, src.h, 0, 0, GRID_SIZE.w, GRID_SIZE.h);
      });

      callback();
    });

    return tiles;
  }

  function isWallAt(col, row) {
    return map.walls[col] && map.walls[col][row] || false;
  }

  function getTileAt(tiles, col, row) {
    const neighborsStates = {
      1: isWallAt(col, row - 1),
      2: isWallAt(col - 1, row),
      4: isWallAt(col + 1, row),
      8: isWallAt(col, row + 1),
    };

    const index = _.reduce(neighborsStates, (result, state, bit) => (
      result + state * bit
    ), 0);

    return tiles[index];
  }

  function renderTileAt(col, row) {
    context.clearRect(col * GRID_SIZE.w, row * GRID_SIZE.h, GRID_SIZE.w, GRID_SIZE.h);

    if(isWallAt(col, row)) {
      const tile = getTileAt(wallTiles, col, row);

      context.fillStyle = `white`;
      context.strokeStyle = 'rgba(255, 255, 255, 0.2)';

      context.save();
      context.translate(col * GRID_SIZE.w, row * GRID_SIZE.h);
      context.drawImage(tile, 0, 0, GRID_SIZE.w, GRID_SIZE.h);
      context.strokeRect(0, 0, GRID_SIZE.w, GRID_SIZE.h);
      context.translate(GRID_SIZE.w / 2, GRID_SIZE.h / 2);

      context.restore();
    }
  }

  function modifyWalls(pos, state) {
    const col = pos.col;
    const row = pos.row;

    if(!map.walls[col]) {
      map.walls[col] = [];
    }

    map.walls[col][row] = state;

    const neighbors = [
      [col, row - 1],
      [col - 1, row],
      [col + 1, row],
      [col, row + 1]
    ];

    neighbors.forEach(neighbor => {
      renderTileAt(neighbor[0], neighbor[1])
    });

    renderTileAt(col, row);
  }

  document.addEventListener('contextmenu', e => {
    e.preventDefault();
  });

  document.addEventListener('mousedown', e => {
    let pos = mouseToGrid(e);

    const prevState = map.walls[pos.col] && map.walls[pos.col][pos.row];
    const state = !prevState;

    modifyWalls(pos, state);

    function mouseMove(e) {
      const movePos = mouseToGrid(e);

      if(movePos.col !== pos.col || movePos.row !== pos.row) {
        modifyWalls(movePos, state);
        pos = movePos;
      }
    }

    function mouseUp() {
      document.removeEventListener('mousemove', mouseMove);
      document.removeEventListener('mouseup', mouseUp);
    }

    document.addEventListener('mousemove', mouseMove);
    document.addEventListener('mouseup', mouseUp);
  });

  window.addEventListener('load', () => {
    document.body.appendChild(canvas);
    // renderMap();
  });
</script>
